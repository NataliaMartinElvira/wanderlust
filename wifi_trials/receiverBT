#include <BLEDevice.h>
#include <BLEScan.h>
#include <BLEAdvertisedDevice.h>
#include <BLEClient.h> 
#include <BLERemoteCharacteristic.h> 
#include <BLERemoteService.h> 
#include <WiFi.h> 

// --- Configuration ---
#define SERVICE_UUID "4FAF0C20-1FB5-459E-8AF2-EAC540000001" 
#define SENSOR_CHAR_UUID "BEB5483E-36E1-4688-B7F5-EA07361B26A8"
#define MAX_NODES 2

// EXPANDED DATA STRUCTURE (MUST match the Server)
typedef struct struct_message {
    int id;
    unsigned long timestamp;
    float acc_x;
    float acc_y;
    float acc_z;
    float pitch;
    float roll;
    float gyr_x;
    float gyr_y;
    float gyr_z;
} struct_message;

struct_message receivedData;

// Structures to manage multiple connections
typedef struct {
  BLEClient* client;
  BLEAddress address;
  bool connected;
} node_info_t;

node_info_t nodes[MAX_NODES];
int nodeCount = 0;

// FORWARD DECLARATION: Necessary for older cores
bool connectToServer(node_info_t* node); 

// Global notification handler function (REQUIRED FOR OLDER CORES)
void notifyCallback(BLERemoteCharacteristic* pRemoteCharacteristic, uint8_t* pData, size_t length, bool isNotify) {
    if (length == sizeof(struct_message)) {
        // Copy data into the struct
        memcpy(&receivedData, pData, sizeof(struct_message));
        
        // Print the data to PC Serial Monitor
        Serial.print("Node: ");
        Serial.print(receivedData.id);
        Serial.print(" | Acc X: ");
        Serial.print(receivedData.acc_x, 3);
        Serial.print(" | Roll: ");
        Serial.println(receivedData.roll, 2);
        // ... print all other fields
    }
}

// Callback for handling discovered devices
class MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {
    void onResult(BLEAdvertisedDevice advertisedDevice) {
        if (nodeCount >= MAX_NODES) return; 

        // CRITICAL FIX: Explicitly convert SERVICE_UUID to a BLEUUID object for comparison
        if (advertisedDevice.haveServiceUUID() && advertisedDevice.getServiceUUID().equals(BLEUUID(SERVICE_UUID))) {
            Serial.printf("Found IMU Device: %s\n", advertisedDevice.getName().c_str());
            
            bool alreadyKnown = false;
            for (int i = 0; i < nodeCount; i++) {
                if (nodes[i].address.equals(advertisedDevice.getAddress())) {
                    alreadyKnown = true;
                    break;
                }
            }
            
            if (!alreadyKnown) {
                nodes[nodeCount].address = advertisedDevice.getAddress();
                if (connectToServer(&nodes[nodeCount])) {
                    nodeCount++;
                }
            }
        }
    }
};

// Function to connect and subscribe to a server
bool connectToServer(node_info_t* node) {
    Serial.printf("Attempting to connect to %s\n", node->address.toString().c_str());
    
    node->client = BLEDevice::createClient();
    
    if (!node->client->connect(node->address)) {
        Serial.println("Connection failed.");
        return false;
    }

    // CRITICAL FIX: Explicitly convert SERVICE_UUID to a BLEUUID object for service search
    BLERemoteService* pRemoteService = node->client->getService(BLEUUID(SERVICE_UUID));
    if (pRemoteService == nullptr) {
        Serial.println("Failed to find service.");
        node->client->disconnect();
        return false;
    }
    
    // CRITICAL FIX: Explicitly convert SENSOR_CHAR_UUID to a BLEUUID object for characteristic search
    BLERemoteCharacteristic* pRemoteCharacteristic = pRemoteService->getCharacteristic(BLEUUID(SENSOR_CHAR_UUID));
    if (pRemoteCharacteristic == nullptr) {
        Serial.println("Failed to find characteristic.");
        node->client->disconnect();
        return false;
    }

    // Register for notifications (subscribe to data stream)
    if(pRemoteCharacteristic->canNotify()) {
        pRemoteCharacteristic->registerForNotify(notifyCallback, false);
        node->connected = true;
        Serial.printf("Connected and subscribed to Node %s\n", node->address.toString().c_str());
        return true;
    }
    
    return false;
}

void setup() {
    Serial.begin(115200);
    Serial.println("Starting BLE Client...");

    // Initialize BLE
    BLEDevice::init("");
    BLEScan* pBLEScan = BLEDevice::getScan();
    pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());
    pBLEScan->setActiveScan(true); 
    pBLEScan->setInterval(100);
    pBLEScan->setWindow(99);  
    
    // Scan for 10 seconds to find initial devices
    pBLEScan->start(10, false);
}

void loop() {
    // Re-scan if both nodes haven't been connected yet
    if (nodeCount < MAX_NODES) {
        BLEDevice::getScan()->start(5); 
    }
    
    // Use FreeRTOS delay for stability
    vTaskDelay(pdMS_TO_TICKS(1000));
}
