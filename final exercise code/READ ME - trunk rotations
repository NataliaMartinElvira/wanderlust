# Seated Trunk Rotation – Real-Time IMU Feedback with Unity TCP Integration

This repository contains the script:

> `final_trunk rotations_with UI feedback.py`

It performs **real-time seated trunk rotation analysis** using **two IMUs** (upper trunk and pelvis) and sends **coaching events** to a Unity application via **TCP**.

The script:

- Estimates **trunk rotation** (thorax vs pelvis) around a **pelvis spine axis**
- Detects **left and right reps**
- Provides **per-turn feedback** about:
  - Rotation depth (“rotate further”)
  - Hip motion (“keep hips still”)
  - Trunk posture (“keep your trunk more upright”)
  - Movement speed (“slow down”)
- Classifies **rep speed** as:
  - Normal
  - Too fast
  - Too slow
- Sends **simple string events** to Unity for audio/visual feedback.

---

## 1. System Overview

### 1.1 Hardware Setup

- **IMUs**  
  You need two IMUs streaming data over WiFi:

  - Upper trunk IMU: `UPPER_ID = "IMU_CH3"`
  - Pelvis IMU: `PELVIS_ID = "IMU_CH0"`

- **IMU streaming server**
  - Host: `192.168.4.1`
  - Port: `3333`
  - Each line is a CSV with the following header:

    ```text
    imu_id,time_ms,acc_x_g,acc_y_g,acc_z_g,pitch_deg,roll_deg,gyr_x_dps,gyr_y_dps,gyr_z_dps
    ```

### 1.2 Software Components

- **Python script** (this file)
  - Connects to IMU WiFi stream
  - Runs orientation filters (Madgwick)
  - Computes relative trunk–pelvis orientation and axial rotation
  - Detects reps + compensation patterns
  - Sends events to Unity over TCP

- **Unity application**
  - Runs a TCP server:
    - `UI_HOST = "127.0.0.1"`
    - `UI_PORT = 5001`
  - Receives one-line events such as `REP_REACHED`, `SLOW_DOWN`, etc.
  - Plays audio / shows visual feedback based on those events.

---

## 2. Dependencies & Installation

### 2.1 Python Dependencies

Install required Python packages:

```bash
pip install numpy scipy ahrs


The script uses:

numpy – numerical computations

scipy.signal.savgol_filter – smoothing the axial angle

ahrs.filters.Madgwick – IMU orientation estimation

Python standard library: socket, time, sys, datetime

2.2 Running the Script

Make sure your IMU streamer is running and accessible at 192.168.4.1:3333.

Start your Unity app with a TCP server listening on 127.0.0.1:5001.

Run the Python script from a terminal:

python seated_trunk_rotation_axial_realtime_turnstate_unity_tcp.py


You should see:

Connection attempts

A 3 s calibration phase

Then a live bar showing axial angle, velocity and pelvis deviation

Real-time feedback messages and rep detection output.

3. Unity TCP Integration
3.1 Connection

The script acts as a TCP client and attempts to connect to Unity:

Host: UI_HOST = "127.0.0.1"

Port: UI_PORT = 5001

The Unity app must:

Create a TcpListener on port 5001

Accept a client connection (from the Python script)

Read incoming data line-by-line (terminated with \n)

3.2 Events Sent to Unity

Events are sent as uppercase ASCII strings, each followed by a newline:

UI_CONNECTED
IMU_CONNECTED
CALIB_DONE
REP_REACHED
REP_TOO_FAST
REP_TOO_SLOW
SLOW_DOWN
UPRIGHT
HIPS_STILL
ROTATE_FURTHER


These events are side-agnostic (Unity does not need to know left vs right).

Connection / Status Events

UI_CONNECTED
Sent when the Python script successfully connects to the Unity TCP server.

IMU_CONNECTED
Sent when the Python script successfully connects to the IMU streaming server (HOST:PORT).

CALIB_DONE
Sent when the initial 3-second calibration phase is complete.

Rep-Related Events

REP_REACHED
A repetition (left or right) has reached its axial target (≥ right target or ≤ left target).

REP_TOO_FAST
On a rep that reached its target, if the duration from turn start is less than REP_MIN_DURATION_S, the rep is classified as too fast.

REP_TOO_SLOW
On a rep that reached its target, if the duration from turn start is greater than REP_MAX_DURATION_S, the rep is classified as too slow.

Per-Turn Coaching Events

These are sent at most once per turn:

SLOW_DOWN
Angular velocity exceeds MAX_YAW_SPEED_DPS.

UPRIGHT
Trunk bending (relative roll/pitch vs neutral) exceeds MAX_COMP_ANGLE_DEG.

HIPS_STILL
Pelvis yaw deviation vs calibration exceeds MAX_PELVIS_DRIFT_DEG.

ROTATE_FURTHER
Patient is turning in the correct direction, moving deeper, but has not yet reached a sufficient fraction of the target rotation (DEPTH_WARN_FRACTION).

3.3 Example Unity Handling (Pseudo-code)

In Unity C# (pseudo-code):

switch (message.Trim())
{
    case "UI_CONNECTED":
        // Show "UI linked" indicator
        break;
    case "IMU_CONNECTED":
        // Show "Sensors connected"
        break;
    case "CALIB_DONE":
        PlayAudio("calibration_done");
        break;
    case "REP_REACHED":
        PlayAudio("rep_reached");
        break;
    case "REP_TOO_FAST":
        PlayAudio("rep_too_fast");
        break;
    case "REP_TOO_SLOW":
        PlayAudio("rep_too_slow");
        break;
    case "SLOW_DOWN":
        PlayAudio("slow_down");
        break;
    case "UPRIGHT":
        PlayAudio("upright");
        break;
    case "HIPS_STILL":
        PlayAudio("hips_still");
        break;
    case "ROTATE_FURTHER":
        PlayAudio("rotate_further");
        break;
}

4. High-Level Algorithm
4.1 Orientation Estimation

For each IMU (upper trunk and pelvis):

A Madgwick filter (ahrs.filters.Madgwick) is run at SAMPLE_HZ = 20.0 Hz.

Inputs:

Gyroscope (rad/s), optionally bias-corrected after calibration

Accelerometer (g)

Outputs:

q_u – quaternion orientation of upper IMU (body → world)

q_p – quaternion orientation of pelvis IMU (body → world)

Relative orientation:

q_rel = quat_mul(q_u, quat_conj(q_p))


From q_rel, the script retrieves:

Relative roll and pitch (for trunk bending compensation)

A geometric axial angle around a defined spine axis.

4.2 Defining the Spine Axis

The pelvis IMU’s +X axis is assumed to align approximately with the spine axis.

In pelvis body coordinates: spine_axis_body = [1, 0, 0]

Transformed into world coordinates via pelvis rotation matrix Rp:

spine_axis_world = Rp @ spine_axis_body

4.3 Axial Trunk Rotation (Geometric Angle)

The function axial_angle_about_axis(q_rel, axis_world) computes the rotation about axis_world from q_rel using the vector part of the quaternion.

Result: a signed angle in degrees in the range [-180°, 180°].

Positive = rotation to the right

Negative = rotation to the left

4.4 Calibration

The first CALIBRATION_SECONDS = 3.0 seconds are used for baseline calibration:

Assumes patient is still in neutral seated posture.

Collects:

Axial angle (coll_rel)

Pelvis yaw (coll_pel)

Relative roll/pitch (coll_r_rel, coll_p_rel)

Gyro samples for upper and pelvis (gyr_u_cal, gyr_p_cal)

After calibration:

yaw_rel_bias – median axial angle

pel_yaw_bias – median pelvis yaw

gyr_u_bias, gyr_p_bias – gyro bias vectors (medians)

r_rel_bias, p_rel_bias – relative roll & pitch baselines

From this point on, all angles and deviations are measured relative to this baseline.
Unity event CALIB_DONE is sent at this moment.

4.5 Drift Control – Relative Gyro Fusion

The script maintains a differential-gyro integrator:

rel_axial_int – integrated relative angular velocity of trunk vs pelvis projected onto the spine axis.

Steps:

Transform gyro readings into world coordinates (gw_u, gw_p).

Compute relative angular velocity:

rel_omega_world = gw_u - gw_p
axial_omega_rad = dot(rel_omega_world, axis_unit)
axial_omega_dps = degrees(axial_omega_rad)


Integration with leak:

If moving (gyro above STILL_GYR_DPS):

rel_axial_int += axial_omega_dps * dt

If still:

Exponential leak: rel_axial_int *= exp(-dt / REL_LEAK_TAU_STILL_S)

Blend towards geometric angle (axial_bc):

rel_axial_int = (1 - alpha) * rel_axial_int + alpha * axial_bc


Clamp integrator drift:

diff_int_geom = angle_wrap_deg(rel_axial_int - axial_bc)
if abs(diff_int_geom) > REL_MAX_INT_OFFSET_DEG:
    rel_axial_int = axial_bc + clip(diff_int_geom, -REL_MAX_INT_OFFSET_DEG, REL_MAX_INT_OFFSET_DEG)
rel_axial_int = angle_wrap_deg(rel_axial_int)


Complementary fusion:

When moving: small gyro weight (w_gyro = 0.3)

When still: w_gyro = 0.0 (pure geometry)

axial_fused = (1.0 - w_gyro) * axial_bc + w_gyro * rel_axial_int
axial_fused = angle_wrap_deg(axial_fused)

4.6 Smoothing & Velocity

The fused axial angle is appended to yaw_buf.

A Savitzky–Golay filter (savgol_filter) is applied over the last SMOOTH_WINDOW samples to get y_smooth.

Axial velocity (deg/s) is estimated from the smoothed angle:

yaw_vel_dps = (y_smooth - last_yaw) / dt

5. Tunable Parameters

These are defined at the top of the script and can be customized.

5.1 Core Timing & Calibration
SAMPLE_HZ           = 20.0
CALIBRATION_SECONDS = 3.0
PAIR_MAX_AGE_S      = 0.15


SAMPLE_HZ – expected sampling rate of IMU updates.

CALIBRATION_SECONDS – duration of initial stillness-based calibration.

PAIR_MAX_AGE_S – max age mismatch between upper and pelvis IMU samples before discarding pairing.

5.2 Axial Target & Hysteresis
AXIAL_TARGET_RIGHT_DEG = 10.0
AXIAL_TARGET_LEFT_DEG  = 10.0
YAW_HYST_DEG           = 5.0


Targets for right/left rotations (reps are detected when these thresholds are crossed).

YAW_HYST_DEG – hysteresis band around targets to avoid repeated entering/exiting.

5.3 Speed, Posture & Pelvis Constraints
MAX_YAW_SPEED_DPS   = 120.0  # for SLOW_DOWN
MAX_COMP_ANGLE_DEG  = 15.0   # trunk bending vs neutral
MAX_PELVIS_DRIFT_DEG= 10.0   # pelvis yaw vs neutral
STILL_GYR_DPS       = 2.5
ACC_STILL_TOL_G     = 0.05


MAX_YAW_SPEED_DPS – max allowed axial speed before “Slow down” feedback.

MAX_COMP_ANGLE_DEG – allowable trunk bending angle from neutral.

MAX_PELVIS_DRIFT_DEG – allowable pelvis yaw deviation from neutral.

STILL_GYR_DPS + ACC_STILL_TOL_G – thresholds used in is_still to detect genuine stillness.

5.4 Rep Logic & Speed Classification
MIN_REP_GAP_S      = 1.0
REP_MIN_DURATION_S = 0.5
REP_MAX_DURATION_S = 3.0


MIN_REP_GAP_S – minimum time between reps to avoid double-counting.

REP_MIN_DURATION_S – reps faster than this are flagged as too fast (REP_TOO_FAST).

REP_MAX_DURATION_S – reps slower than this are flagged as too slow (REP_TOO_SLOW).

5.5 Real-Time Turn Feedback
DIR_MIN_DEG              = 5.0
TURN_END_DEG             = 3.0
TURN_FEEDBACK_INTERVAL_S = 0.4
DEPTH_WARN_FRACTION      = 0.6
DEPTH_WARN_MIN_TIME_S    = 0.2
MIN_DEPTH_VEL_DPS        = 3.0


DIR_MIN_DEG – minimal axial angle magnitude to consider a turn active.

TURN_END_DEG – angle magnitude below which a turn is considered ended.

TURN_FEEDBACK_INTERVAL_S – minimum time between feedback messages during a turn.

DEPTH_WARN_FRACTION – fraction of target rotation below which the script may say “Rotate further”.

DEPTH_WARN_MIN_TIME_S – minimal time since turn start before “Rotate further” can be issued.

MIN_DEPTH_VEL_DPS – minimal angular velocity in the same direction as the turn to issue “Rotate further”.

5.6 Drift Control Parameters
REL_LEAK_TAU_STILL_S   = 6.0
REL_MIN_DT_FRAC        = 0.4
REL_MAX_INT_OFFSET_DEG = 25.0


REL_LEAK_TAU_STILL_S – time constant for integrator leak at rest.

REL_MIN_DT_FRAC – guard to ensure dt is large enough to integrate.

REL_MAX_INT_OFFSET_DEG – max allowed offset between gyro integrator and geometric angle.

6. Real-Time Feedback & Rep Detection Logic
6.1 Stillness Gating & Freezing

For each IMU, is_still(gyr, acc) checks:

Gyro magnitude < STILL_GYR_DPS

Acc magnitude ≈ 1g (within ±ACC_STILL_TOL_G)

If both IMUs are still after calibration, the script:

Takes a snapshot of q_u and q_p

Reuses those frozen quaternions while stillness holds → reduces drift.

6.2 Bending & Pelvis Hysteresis

Raw checks:

raw_bending_now = (
    abs(p_rel_dev) > MAX_COMP_ANGLE_DEG or
    abs(r_rel_dev) > MAX_COMP_ANGLE_DEG
)

raw_pelvis_violation_now = abs(y_pel_dev) > MAX_PELVIS_DRIFT_DEG


Hysteresis thresholds:

BEND_OUT_DEG   = max(0.0, MAX_COMP_ANGLE_DEG - 3.0)
PELVIS_OUT_DEG = max(0.0, MAX_PELVIS_DRIFT_DEG - 3.0)


bending_state and pelvis_state maintain whether we are currently in a bending/pelvis violation region.

This avoids fast toggling of warnings around the exact threshold.

6.3 Turn State Machine & Per-Turn Feedback

A turn is active when:

abs_axial = abs(y_smooth) > DIR_MIN_DEG

moving == True (based on gyro magnitude)

When a turn becomes active (or direction changes):

turn_state_dir = +1 for right, -1 for left

turn_state_start_t = t_dev

Per-turn flags (warned_speed_this_turn, etc.) are reset.

Every TURN_FEEDBACK_INTERVAL_S seconds during an active turn:

Compute time_in_turn and check if enough time has passed since last feedback.

Evaluate, in order:

Speed: if too_fast_now and not yet warned → “Slow down…” (SLOW_DOWN)

Bending: if bending_now and not yet warned → “Keep your trunk more upright…” (UPRIGHT)

Pelvis: if pelvis_violation_now and not yet warned → “Keep your hips still…” (HIPS_STILL)

Depth: if moving deeper, not deep enough (DEPTH_WARN_FRACTION * target_for_dir), after DEPTH_WARN_MIN_TIME_S → “Rotate further…” (ROTATE_FURTHER)

When a turn ends (angle < TURN_END_DEG or moving == False):

turn_state_dir = 0

Per-turn flags are cleared.

6.4 Rep Detection & Speed Classification

Using y_smooth:

up_th    = AXIAL_TARGET_RIGHT_DEG
down_th  = -AXIAL_TARGET_LEFT_DEG
exit_pos = up_th   - YAW_HYST_DEG
exit_neg = down_th + YAW_HYST_DEG


Right rep:

Enter when y_smooth >= up_th and min gap since last rep.

Left rep:

Enter when y_smooth <= down_th and min gap since last rep.

When threshold crossed:

Append (t_dev, y_smooth) to peaks_R or peaks_L.

last_peak_t = t_dev

Terminal: ✓ Target reached (Right/Left) at X°

Unity: REP_REACHED

Then rep-speed classification:

rep_duration = t_dev - turn_state_start_t

if rep_duration < REP_MIN_DURATION_S:
    # too fast
    send_ui_event("REP_TOO_FAST")
elif rep_duration > REP_MAX_DURATION_S:
    # too slow
    send_ui_event("REP_TOO_SLOW")


Hysteresis exits:

Right: zone_pos cleared when y_smooth < exit_pos

Left: zone_neg cleared when y_smooth > exit_neg

7. Terminal Output & Session Summary
7.1 Live Status Line

On every loop iteration, a compact status line is printed:

[------|--------------] +x.y° | axial +x.y° | vel +v°/s | pelvis +p° 


Components:

ASCII bar representing axial angle (bar() function)

Numeric values:

axial – smoothed axial angle in degrees

vel – axial angular velocity in deg/s

pelvis – pelvis yaw deviation vs calibration in degrees

7.2 Feedback Messages

Human-readable messages (with timestamp and color) printed when:

Calibration completes

Rep targets are reached

Reps are too fast/slow

Coaching feedback is given (“Slow down…”, “Keep hips still…”, etc.)

Unparsed IMU lines are encountered

Connection errors occur

7.3 Summary on Exit

When the script ends (Ctrl+C or connection error):

Prints total number of left/right peaks:

Session summary: peaks L=X, R=Y


If available:

Left mean peak angle

Right mean peak angle

Asymmetry: (Right mean - Left mean) in degrees

8. Typical Workflow

Start IMUs & Unity

Ensure IMUs are streaming to 192.168.4.1:3333.

Start Unity TCP server on 127.0.0.1:5001.

Run the Python script

It connects to Unity (UI_CONNECTED) and IMU server (IMU_CONNECTED).

It performs a 3-second calibration:

Ask patient to sit still in neutral sipping posture.

Event CALIB_DONE is sent when done.

Exercise

Patient performs seated trunk rotations.

Terminal shows live angles and messages.

Unity plays audio for:

Rep reached

Too fast / too slow

Hips not still

Not upright

Need to rotate further

Too fast turning

Stop

Press Ctrl+C in the terminal.

Review session summary in the terminal.

Use logged events or Unity responses for further analysis.

9. Customization Suggestions

Adjust targets (AXIAL_TARGET_*_DEG) for different exercises (larger ROM, smaller ROM).

Tune compensation thresholds (MAX_COMP_ANGLE_DEG, MAX_PELVIS_DRIFT_DEG) based on:

Clinical preferences

Patient-specific calibration routines

Refine speed boundaries (REP_MIN_DURATION_S, REP_MAX_DURATION_S) using observed “good” reps.

Extend Unity to:

Show live angle bars

Count reps

Log events for later review

